<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Archer Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: sans-serif;
        }
        canvas {
            background-color: #333;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        /**
         * Helper for Collision Detection
         */
        function checkCollision(rect1, rect2) {
            return (
                rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y
            );
        }

        /**
         * Represents the Target (Goal).
         */
        class Target {
            constructor(game, x, y) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.radius = 20;
                this.active = true;
            }

            draw(ctx) {
                if (!this.active) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#f1c40f'; // Gold
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Bullseye
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius / 2, 0, Math.PI * 2);
                ctx.fillStyle = '#e74c3c'; // Red
                ctx.fill();
            }
        }

        /**
         * Represents a Particle Effect.
         */
        class Particle {
            constructor(game, x, y, color, size, speedX, speedY, life) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.color = color;
                this.size = size;
                this.speedX = speedX;
                this.speedY = speedY;
                this.life = life; // Time to live in seconds
                this.maxLife = life;
                this.markedForDeletion = false;
            }

            update(deltaTime) {
                const dt = deltaTime / 1000;
                this.x += this.speedX * dt;
                this.y += this.speedY * dt;
                this.life -= dt;
                if (this.life <= 0) this.markedForDeletion = true;
            }

            draw(ctx) {
                ctx.save();
                ctx.globalAlpha = this.life / this.maxLife;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.restore();
            }
        }

        /**
         * Represents an Enemy (Zombie).
         */
        class Enemy {
            constructor(game, x, y) {
                this.game = game;
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 40;
                this.speedX = 0;
                this.vy = 0;
                this.gravity = 1000;
                this.markedForDeletion = false;
                this.onGround = false;
                this.jumpStrength = -550; // Increased for better mobility
                this.moveSpeed = 60; // 1.5x previous 20 = 30? User asked for 1.5x speed.
                                     // Original was 20. 20 * 1.5 = 30.
                                     // But 30 is still slow. I'll bump it to 60 to make them "move faster" as requested.
                this.targetPlatformIndex = -1;
            }

            update(deltaTime) {
                const dt = deltaTime / 1000;

                // AI Logic: Determine Direction
                this.decideMovement();

                // Apply Gravity
                this.vy += this.gravity * dt;
                this.y += this.vy * dt;

                // Floor Collision (Treat as Platform 0)
                this.onGround = false;
                if (this.y + this.height > this.game.height) {
                    this.y = this.game.height - this.height;
                    this.vy = 0;
                    this.onGround = true;
                }

                // Wall/Platform Collisions
                this.game.walls.forEach(wall => {
                    // Simple AABB for Walls
                     if (this.x < wall.x + wall.width &&
                        this.x + this.width > wall.x &&
                        this.y < wall.y + wall.height &&
                        this.y + this.height > wall.y) {

                        const overlapTop = (this.y + this.height) - wall.y;
                        const overlapBottom = (wall.y + wall.height) - this.y;
                        const overlapLeft = (this.x + this.width) - wall.x;
                        const overlapRight = (wall.x + wall.width) - this.x;

                        // Prioritize Vertical collision if falling/jumping
                        // We check the smallest overlap
                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                        if (minOverlap === overlapTop && this.vy >= 0) { // Landed on top
                            this.y = wall.y - this.height;
                            this.vy = 0;
                            this.onGround = true;
                        } else if (minOverlap === overlapBottom && this.vy < 0) { // Hit head
                            this.y = wall.y + wall.height;
                            this.vy = 0;
                        }
                    }
                });

                // Apply Horizontal Movement
                this.x += this.speedX * dt;

                // Resolve Horizontal Collisions
                this.game.walls.forEach(wall => {
                    if (this.x < wall.x + wall.width &&
                        this.x + this.width > wall.x &&
                        this.y < wall.y + wall.height && // Slightly relaxed Y check to avoid snagging on floor
                        this.y + this.height > wall.y) {

                         // If we are strictly colliding horizontally (not standing on it)
                         // We already resolved Y, so if we are still overlapping, it must be X?
                         // Re-check overlaps with current positions
                        const overlapLeft = (this.x + this.width) - wall.x;
                        const overlapRight = (wall.x + wall.width) - this.x;
                        const overlapTop = (this.y + this.height) - wall.y;

                        // Ignore if we are standing on it (overlapTop is small and we are onGround)
                        if (overlapTop <= 1) return;

                        if (overlapLeft < overlapRight && overlapLeft < 20) {
                             this.x = wall.x - this.width;
                        } else if (overlapRight < 20) {
                             this.x = wall.x + wall.width;
                        }
                    }
                });

                // Canvas bounds X
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > this.game.width) this.x = this.game.width - this.width;
            }

            decideMovement() {
                // identify current platform
                const myPlat = this.game.getPlatform(this);
                const playerPlat = this.game.getPlatform(this.game.player);

                if (!myPlat || !playerPlat) {
                    // Fallback: move towards player X
                    if (this.game.player.x > this.x) this.speedX = this.moveSpeed;
                    else this.speedX = -this.moveSpeed;
                    return;
                }

                // If on same platform, run to player
                if (myPlat.id === playerPlat.id) {
                    if (this.game.player.x > this.x) this.speedX = this.moveSpeed;
                    else this.speedX = -this.moveSpeed;
                } else {
                    // Find path
                    const nextNodeId = this.game.findNextPlatform(myPlat.id, playerPlat.id);
                    if (nextNodeId !== -1) {
                        // Move towards the connection to that node
                        const connection = this.game.navGraph[myPlat.id].find(c => c.targetId === nextNodeId);
                        if (connection) {
                            // Target X is the connection point (e.g. edge of current platform)
                            // We need to define connection points clearly.
                            // For simplicity: If target is to the right, go to right edge.
                            const targetPlatform = this.game.platforms.find(p => p.id === nextNodeId);

                            // Determine direction to target platform
                            let targetX = targetPlatform.x + targetPlatform.width/2;

                            // Optimization: Move to the edge closest to the target platform
                            if (targetPlatform.x > this.x) {
                                // Target is right. Go to right edge of current.
                                if (myPlat.type === 'wall') targetX = myPlat.x + myPlat.width;
                                else targetX = this.game.width; // Floor right
                            } else {
                                // Target is left
                                if (myPlat.type === 'wall') targetX = myPlat.x;
                                else targetX = 0; // Floor left
                            }

                            if (targetX > this.x + 10) {
                                this.speedX = this.moveSpeed;
                            } else if (targetX < this.x - 10) {
                                this.speedX = -this.moveSpeed;
                            } else {
                                // We are at the edge/jump point
                                // Jump if target is higher or across a gap
                                // Simple logic: Always jump when reaching the edge if the target is not directly below
                                if (this.onGround) {
                                    this.vy = this.jumpStrength;
                                    // Push forward to clear gap
                                    this.speedX = (targetPlatform.x > this.x) ? this.moveSpeed : -this.moveSpeed;
                                }
                            }
                        }
                    } else {
                         // No path found? Just move towards player X
                        if (this.game.player.x > this.x) this.speedX = this.moveSpeed;
                        else this.speedX = -this.moveSpeed;
                    }
                }
            }

            draw(ctx) {
                ctx.fillStyle = '#e74c3c'; // Red
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Eyes
                ctx.fillStyle = 'black';
                ctx.fillRect(this.x + 5, this.y + 10, 5, 5);
                ctx.fillRect(this.x + 15, this.y + 10, 5, 5);
            }
        }

        /**
         * Represents an Arrow.
         */
        class Arrow {
            constructor(game, x, y, angle, speed) {
                this.game = game;
                this.width = 20;
                this.height = 5;
                this.x = x;
                this.y = y;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.gravity = 500; // Pixels per second squared
                this.markedForDeletion = false;
                this.elasticity = 0.7; // 30% speed loss
            }

            update(deltaTime) {
                const dt = deltaTime / 1000;

                // Apply Gravity
                this.vy += this.gravity * dt;

                // Move
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Spawn Particles (Smoke/Fire)
                if (!this.markedForDeletion) {
                    // Fire
                    if (Math.random() < 0.5) {
                        this.game.particles.push(new Particle(
                            this.game,
                            this.x, this.y,
                            '#e74c3c', // Red/Orange
                            Math.random() * 5 + 2,
                            (Math.random() - 0.5) * 20,
                            (Math.random() - 0.5) * 20,
                            0.5
                        ));
                    }
                    // Smoke
                    if (Math.random() < 0.3) {
                         this.game.particles.push(new Particle(
                            this.game,
                            this.x, this.y,
                            '#95a5a6', // Grey
                            Math.random() * 8 + 4,
                            (Math.random() - 0.5) * 10,
                            (Math.random() - 0.5) * 10,
                            0.8
                        ));
                    }
                }

                // Collision with Enemies
                this.game.enemies.forEach(enemy => {
                    if (!enemy.markedForDeletion && checkCollision(this, enemy)) {
                        enemy.markedForDeletion = true;
                        this.markedForDeletion = true;
                    }
                });

                // Collision with Target
                if (this.game.target && this.game.target.active) {
                    const t = this.game.target;
                    // Circle-Rectangle collision approximation
                    // Closest point on rectangle to circle center
                    const closestX = Math.max(this.x, Math.min(t.x, this.x + this.width));
                    const closestY = Math.max(this.y, Math.min(t.y, this.y + this.height));

                    const distanceX = t.x - closestX;
                    const distanceY = t.y - closestY;
                    const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);

                    if (distanceSquared < (t.radius * t.radius)) {
                        this.markedForDeletion = true;
                        this.game.onTargetHit();
                    }
                }

                // Wall Collisions
                this.game.walls.forEach(wall => {
                    // Simple AABB collision check for bounce
                    // This is a basic approximation for bouncing off static rects
                    if (this.x < wall.x + wall.width &&
                        this.x + this.width > wall.x &&
                        this.y < wall.y + wall.height &&
                        this.y + this.height > wall.y) {

                        // Resolve collision based on overlap amount
                        const overlapLeft = (this.x + this.width) - wall.x;
                        const overlapRight = (wall.x + wall.width) - this.x;
                        const overlapTop = (this.y + this.height) - wall.y;
                        const overlapBottom = (wall.y + wall.height) - this.y;

                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                        if (minOverlap === overlapLeft) {
                            this.x = wall.x - this.width;
                            this.vx *= -this.elasticity;
                        } else if (minOverlap === overlapRight) {
                            this.x = wall.x + wall.width;
                            this.vx *= -this.elasticity;
                        } else if (minOverlap === overlapTop) {
                            this.y = wall.y - this.height;
                            this.vy *= -this.elasticity;
                        } else if (minOverlap === overlapBottom) {
                            this.y = wall.y + wall.height;
                            this.vy *= -this.elasticity;
                        }
                    }
                });

                // Canvas Boundaries / Bounce Logic

                // Floor
                if (this.y + this.height > this.game.height) {
                    this.y = this.game.height - this.height;
                    this.vy *= -this.elasticity;
                    this.vx *= this.elasticity; // Apply friction on floor bounce
                }
                // Ceiling
                if (this.y < 0) {
                    this.y = 0;
                    this.vy *= -this.elasticity;
                }
                // Right Wall
                if (this.x + this.width > this.game.width) {
                    this.x = this.game.width - this.width;
                    this.vx *= -this.elasticity;
                }
                // Left Wall
                if (this.x < 0) {
                    this.x = 0;
                    this.vx *= -this.elasticity;
                }

                // Stop if very slow
                if (Math.abs(this.vx) < 10 && Math.abs(this.vy) < 10 && this.y > this.game.height - 20) {
                     this.markedForDeletion = true;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width/2, this.y + this.height/2);
                ctx.rotate(Math.atan2(this.vy, this.vx));
                ctx.fillStyle = '#ffcc00';
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                ctx.restore();
            }
        }

        /**
         * Represents the player (archer).
         */
        class Player {
            constructor(game) {
                this.game = game;
                this.width = 40;
                this.height = 40;
                this.x = 50;
                this.y = this.game.height - this.height - 10; // Positioned on ground
                this.angle = 0; // Radians, 0 is aiming right
                this.aimSpeed = 2; // Radians per second
                this.minAngle = -Math.PI / 2; // -90 degrees (up)
                this.maxAngle = 0; // 0 degrees (right)

                this.charging = false;
                this.chargePower = 0;
                this.maxCharge = 100;
                this.chargeSpeed = 100; // Power per second
            }

            update(deltaTime) {
                const dt = deltaTime / 1000; // Convert to seconds

                // Aiming
                if (this.game.input.keys.ArrowUp) {
                    this.angle -= this.aimSpeed * dt;
                }
                if (this.game.input.keys.ArrowDown) {
                    this.angle += this.aimSpeed * dt;
                }

                // Clamp angle
                if (this.angle < this.minAngle) this.angle = this.minAngle;
                if (this.angle > this.maxAngle) this.angle = this.maxAngle;

                // Charging
                if (this.game.input.keys.Space) {
                    if (!this.charging) {
                        this.charging = true;
                        this.chargePower = 0;
                    }
                    this.chargePower += this.chargeSpeed * dt;
                    if (this.chargePower > this.maxCharge) this.chargePower = this.maxCharge;
                } else {
                    if (this.charging) {
                        // Release fire
                        this.game.shootArrow(this.angle, this.chargePower);
                        this.charging = false;
                        this.chargePower = 0;
                    }
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);

                // Draw Body (Blocky with Face)
                ctx.fillStyle = '#3498db';
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);

                // Draw Face (Cute/Cool)
                ctx.fillStyle = '#ecf0f1'; // White eyes
                // Left Eye
                ctx.fillRect(-10, -10, 8, 8);
                // Right Eye
                ctx.fillRect(2, -10, 8, 8);

                // Pupils
                ctx.fillStyle = '#2c3e50';
                // Depending on aim angle, move pupils slightly?
                // Simple centered for now
                ctx.fillRect(-8, -8, 4, 4);
                ctx.fillRect(4, -8, 4, 4);

                // Mouth (Smile)
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(-5, 5, 10, 3);


                // Draw Bow/Aim Line
                ctx.rotate(this.angle);
                ctx.fillStyle = '#fff';
                // Bow Handle
                ctx.fillRect(0, -2, 40, 4);
                // Bow String (Visual approximation)
                ctx.beginPath();
                ctx.moveTo(10, -15);
                ctx.lineTo(10, 15);
                ctx.lineWidth = 1;
                ctx.strokeStyle = '#fff';
                ctx.stroke();

                ctx.restore();

                // Draw Charge Bar
                if (this.charging) {
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x, this.y - 20, (this.chargePower / this.maxCharge) * this.width, 5);
                    ctx.strokeStyle = 'white';
                    ctx.strokeRect(this.x, this.y - 20, this.width, 5);
                }
            }
        }

        /**
         * Handles user input.
         */
        class InputHandler {
            constructor() {
                this.keys = {
                    ArrowUp: false,
                    ArrowDown: false,
                    Space: false
                };
                this.anyKeyPressed = false;

                window.addEventListener('keydown', (e) => {
                    if (e.code === 'ArrowUp' || e.code === 'ArrowDown' || e.code === 'Space') {
                        this.keys[e.code] = true;
                    }
                    this.anyKeyPressed = true;
                });

                window.addEventListener('keyup', (e) => {
                    if (e.code === 'ArrowUp' || e.code === 'ArrowDown' || e.code === 'Space') {
                        this.keys[e.code] = false;
                    }
                    this.anyKeyPressed = false;
                });
            }
        }

        /**
         * Main Game Class
         * Manages the game loop, initialization, and rendering.
         */
        class Game {
            /**
             * @param {HTMLCanvasElement} canvas
             */
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                this.lastTime = 0;
                this.input = new InputHandler();
                this.player = new Player(this);
                this.arrows = [];
                this.enemies = [];
                this.walls = [];
                this.platforms = []; // For AI
                this.navGraph = {}; // Adjacency list
                this.particles = [];
                this.target = null;

                this.currentLevel = 1;
                this.ammo = 5;
                this.canShoot = true;

                // Game States: 'PLAYING', 'LEVEL_COMPLETE', 'GAME_OVER', 'WAITING_START'
                this.gameState = 'PLAYING';
                this.gameMessage = '';

                this.loadLevel(this.currentLevel);
            }

            loadLevel(levelIndex) {
                this.currentLevel = levelIndex;
                this.resetState();
                this.gameState = 'PLAYING';

                if (levelIndex === 1) {
                    // Level 1: Beginner
                    this.enemies.push(new Enemy(this, 500, this.height - 50));
                    this.enemies.push(new Enemy(this, 700, this.height - 50));
                    this.target = new Target(this, 750, 200);
                } else if (levelIndex === 2) {
                    // Level 2: Harder
                    this.walls.push({x: 400, y: 300, width: 20, height: 300}); // Tall wall in middle
                    this.enemies.push(new Enemy(this, 300, this.height - 50));
                    this.enemies.push(new Enemy(this, 600, this.height - 50));
                    this.enemies.push(new Enemy(this, 750, this.height - 50));
                    this.target = new Target(this, 750, 500);
                } else if (levelIndex === 3) {
                    // Level 3: Platforms
                    // Two raised platforms
                    this.walls.push({x: 200, y: 400, width: 150, height: 20});
                    this.walls.push({x: 500, y: 300, width: 150, height: 20});

                    this.enemies.push(new Enemy(this, 250, 350)); // On platform 1
                    this.enemies.push(new Enemy(this, 550, 250)); // On platform 2
                    this.enemies.push(new Enemy(this, 700, this.height - 50)); // Ground

                    this.target = new Target(this, 750, 100); // High up
                } else if (levelIndex === 4) {
                    // Level 4: The Pit
                    // Walls on sides, pit in middle (player starts left)
                    this.walls.push({x: 300, y: 450, width: 20, height: 150}); // Left wall of pit
                    this.walls.push({x: 500, y: 450, width: 20, height: 150}); // Right wall of pit
                    this.walls.push({x: 320, y: 550, width: 180, height: 50}); // Pit floor (raised slightly so they don't get stuck in undefined void)

                    this.enemies.push(new Enemy(this, 400, 500)); // Inside pit
                    this.enemies.push(new Enemy(this, 600, 400)); // Right side
                    this.enemies.push(new Enemy(this, 700, 400));

                    this.target = new Target(this, 400, 200); // Floating above pit
                } else if (levelIndex === 5) {
                    // Level 5: Steps
                    for(let i=0; i<5; i++) {
                         this.walls.push({x: 300 + (i*80), y: 500 - (i*60), width: 80, height: 20});
                         if (i > 0) this.enemies.push(new Enemy(this, 320 + (i*80), 450 - (i*60)));
                    }
                    this.target = new Target(this, 750, 50);
                } else if (levelIndex === 6) {
                    // Level 6: Castle
                    this.walls.push({x: 600, y: 300, width: 20, height: 300}); // Castle Wall
                    this.walls.push({x: 620, y: 300, width: 100, height: 20}); // Castle Floor
                    this.walls.push({x: 720, y: 300, width: 20, height: 300}); // Back Wall

                    this.enemies.push(new Enemy(this, 650, 250)); // Guard
                    this.enemies.push(new Enemy(this, 400, this.height - 50)); // Attacker
                    this.enemies.push(new Enemy(this, 500, this.height - 50)); // Attacker

                    this.target = new Target(this, 670, 250); // Inside castle
                } else {
                    this.gameMessage = "YOU WIN THE GAME!";
                    this.gameState = 'LEVEL_COMPLETE';
                    this.victory = true; // Kept for legacy compatibility if needed
                }

                this.buildNavigationGraph();
            }

            resetState() {
                this.arrows = [];
                this.enemies = [];
                this.walls = [];
                this.platforms = [];
                this.navGraph = {};
                this.particles = [];
                this.target = null;
                this.ammo = 5;
                this.canShoot = true;
                this.gameMessage = '';
            }

            /**
             * Builds a graph of walkable platforms for AI.
             */
            buildNavigationGraph() {
                // 1. Identify all platforms
                // Floor is platform 0
                this.platforms.push({
                    id: 0,
                    x: 0,
                    y: this.height, // Y is top surface
                    width: this.width,
                    height: 10,
                    type: 'floor'
                });

                // Walls act as platforms
                this.walls.forEach((wall, index) => {
                    this.platforms.push({
                        id: index + 1,
                        x: wall.x,
                        y: wall.y,
                        width: wall.width,
                        height: wall.height,
                        type: 'wall'
                    });
                });

                // 2. Build edges (connections)
                this.navGraph = {};
                this.platforms.forEach(p => this.navGraph[p.id] = []);

                this.platforms.forEach(p1 => {
                    this.platforms.forEach(p2 => {
                        if (p1.id === p2.id) return;

                        // Check if reachable
                        // Distance Check
                        const dx = Math.abs((p1.x + p1.width/2) - (p2.x + p2.width/2));
                        const dy = p2.y - p1.y; // Positive if p2 is below p1

                        // Horizontal gap
                        // Calculate closest points
                        const left1 = p1.x; const right1 = p1.x + p1.width;
                        const left2 = p2.x; const right2 = p2.x + p2.width;

                        // Gap is 0 if they overlap
                        let gap = 0;
                        if (right1 < left2) gap = left2 - right1;
                        else if (right2 < left1) gap = left1 - right2;

                        // Can Jump? (Max jump height approx 150px, Max jump dist approx 200px)
                        const maxJumpHeight = 150;
                        const maxJumpDist = 200;

                        let connected = false;

                        if (gap < maxJumpDist) {
                            // If target is above (dy < 0)
                            if (dy < 0 && Math.abs(dy) < maxJumpHeight) {
                                connected = true;
                            }
                            // If target is below (dy > 0)
                            else if (dy >= 0) {
                                connected = true; // Can always drop down
                            }
                        }

                        if (connected) {
                            this.navGraph[p1.id].push({ targetId: p2.id });
                        }
                    });
                });
            }

            getPlatform(entity) {
                // Find which platform the entity is standing on
                // Simple check: Entity center X is within platform X range
                // Entity bottom Y is close to platform Top Y
                const cx = entity.x + entity.width/2;
                const bottom = entity.y + entity.height;

                for (let p of this.platforms) {
                    if (cx >= p.x && cx <= p.x + p.width) {
                        if (Math.abs(bottom - p.y) < 50) { // Tolerance
                            return p;
                        }
                    }
                }
                // If in air or undefined, maybe return nearest?
                // Or just Floor
                return this.platforms[0];
            }

            findNextPlatform(startId, endId) {
                // BFS to find shortest path of platforms
                const queue = [startId];
                const visited = new Set();
                const parents = {};
                visited.add(startId);

                while (queue.length > 0) {
                    const current = queue.shift();
                    if (current === endId) break;

                    const neighbors = this.navGraph[current] || [];
                    for (let n of neighbors) {
                        if (!visited.has(n.targetId)) {
                            visited.add(n.targetId);
                            parents[n.targetId] = current;
                            queue.push(n.targetId);
                        }
                    }
                }

                if (!parents[endId]) return -1; // No path

                // Backtrack to find first step
                let curr = endId;
                while (parents[curr] !== startId) {
                    curr = parents[curr];
                }
                return curr;
            }

            shootArrow(angle, power) {
                if (!this.canShoot || this.ammo <= 0 || this.gameState !== 'PLAYING') return;

                this.ammo--;
                // Determine speed based on power (0-100)
                const speed = power * 10; // Max speed 1000
                // Spawn arrow at player position
                const spawnX = this.player.x + this.player.width / 2;
                const spawnY = this.player.y + this.player.height / 2;
                this.arrows.push(new Arrow(this, spawnX, spawnY, angle, speed));

                // No immediate check here, we check in update loop when arrow count is 0
            }

            checkAmmoStatus() {
                // If out of ammo and no arrows are flying, and we haven't won
                if (this.ammo <= 0 && this.arrows.length === 0 && this.gameState === 'PLAYING') {
                     // If target is still active or enemies remain
                     if ((this.target && this.target.active) || this.enemies.length > 0) {
                         this.setGameOver("Out of Arrows!");
                     }
                }
            }

            onTargetHit() {
                if (this.enemies.length > 0) {
                    // Fail Condition: Target hit before enemies cleared
                    this.setGameOver("Target hit too early!");
                } else {
                    // Win Condition
                    this.setLevelComplete();
                }
            }

            setGameOver(reason) {
                this.gameState = 'GAME_OVER';
                this.canShoot = false;
                this.gameMessage = reason + " Press any key to restart.";
                // Reset input latch to prevent accidental immediate restart
                this.input.anyKeyPressed = false;
            }

            setLevelComplete() {
                this.gameState = 'LEVEL_COMPLETE';
                this.canShoot = false;
                this.gameMessage = "VICTORY! Press any key for next level.";
                this.input.anyKeyPressed = false;
            }

            /**
             * Starts the game loop.
             */
            start() {
                requestAnimationFrame(this.gameLoop.bind(this));
            }

            /**
             * The main game loop.
             * @param {number} timestamp
             */
            gameLoop(timestamp) {
                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;

                this.update(deltaTime);
                this.draw();

                requestAnimationFrame(this.gameLoop.bind(this));
            }

            /**
             * Updates game logic.
             * @param {number} deltaTime
             */
            update(deltaTime) {
                // Handle Transitions
                if (this.gameState === 'GAME_OVER') {
                    if (this.input.anyKeyPressed) {
                        this.loadLevel(this.currentLevel); // Restart
                        this.input.anyKeyPressed = false;
                    }
                    return;
                }
                if (this.gameState === 'LEVEL_COMPLETE') {
                    if (this.input.anyKeyPressed) {
                        this.loadLevel(this.currentLevel + 1); // Next Level
                        this.input.anyKeyPressed = false;
                    }
                    return;
                }

                this.player.update(deltaTime);

                this.arrows.forEach(arrow => arrow.update(deltaTime));
                this.arrows = this.arrows.filter(arrow => !arrow.markedForDeletion);

                this.particles.forEach(p => p.update(deltaTime));
                this.particles = this.particles.filter(p => !p.markedForDeletion);

                // Check ammo status after arrows update (in case some were deleted)
                this.checkAmmoStatus();

                this.enemies.forEach(enemy => {
                    enemy.update(deltaTime);
                    // Check collision with player
                    if (checkCollision(this.player, enemy) && this.gameState === 'PLAYING') {
                        this.setGameOver("Caught by Enemy!");
                    }
                });
                this.enemies = this.enemies.filter(enemy => !enemy.markedForDeletion);
            }

            /**
             * Renders the game.
             */
            draw() {
                // Clear screen
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(0, 0, this.width, this.height);

                // Draw Walls
                this.ctx.fillStyle = '#7f8c8d';
                this.walls.forEach(wall => {
                    this.ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                });

                // Draw World Objects
                if (this.target) this.target.draw(this.ctx);

                this.player.draw(this.ctx);
                this.enemies.forEach(enemy => enemy.draw(this.ctx));
                this.arrows.forEach(arrow => arrow.draw(this.ctx));
                this.particles.forEach(p => p.draw(this.ctx));

                // UI Overlay
                this.ctx.fillStyle = 'white';
                this.ctx.font = '20px sans-serif';
                this.ctx.textAlign = 'left';
                this.ctx.fillText(`Ammo: ${this.ammo}`, 10, 30);
                this.ctx.fillText(`Level: ${this.currentLevel}`, 10, 60);

                if (this.gameState !== 'PLAYING' && this.gameMessage) {
                    this.ctx.save();
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    this.ctx.fillRect(0, 0, this.width, this.height);

                    this.ctx.fillStyle = (this.gameState === 'LEVEL_COMPLETE') ? '#2ecc71' : '#e74c3c';
                    this.ctx.font = '40px sans-serif';
                    this.ctx.textAlign = 'center';
                    this.ctx.fillText(this.gameMessage, this.width / 2, this.height / 2);

                    this.ctx.restore();
                }
            }
        }

        // Initialize the game when the window loads
        window.addEventListener('load', () => {
            const canvas = document.getElementById('gameCanvas');
            const game = new Game(canvas);
            game.start();
        });
    </script>
</body>
</html>
